import numpy as np

a = np.arange(15).reshape(3, 5)
print(a)
print(a.shape)  # (3, 5)2维数组中有3个数组，每个数组的长度为5
print(a.ndim)  # 数组的维度为2
print(a.dtype.name)  # 数组中的元素类型int64
print(a.itemsize)  # 数组中每个元素的字节大小8
print(a.size)  # 数组元素的总数15
print(type(a))
print('-----------------------')
b = np.array([6, 7, 8])
print(b)
print(type(b))
print('-----------------------')
a = np.array([2.1, 3.0, 4])
print(a.dtype)
print('-----------------------')
b = np.array([[2, 3], (1.2, 2, 3), (4, 5, 6)])
print(b)
print(b.dtype)
print('-----------------------')
c = np.array([[1, 2], [3, 4]], dtype=complex)  # 指定数组类型
print(c)
print('-----------------------')
d = np.zeros((3, 4))  # 创建由零组成的数组
print(d)
print('-----------------------')
e = np.ones((2, 3, 4), dtype=np.int16)  # 指定第1层2个数组，第2层3个数组，第3层4个元素，类型都是int16，由1组成的数组
print(e)
print('-----------------------')
f = np.empty((2, 3))  # 指定第1层2个数组，第2层3个数组，创建随机数组，数组类型默认是float64
print(f)
print('-----------------------')
g = np.arange(10, 30, 1)  # 返回等差数列，第1个参数是起始点，第2个参数是终止点，第3个参数是步长
print(g)
g = np.arange(0, 2, 0.3)  # 当arange与浮点参数一起使用时，由于浮点数的精度是有限的，通常不可能预测获得的元素数量。出于这个原因，通常最好使用函数linspace，它接收我们想要的元素数量而不是步长作为参数
print(g)
h = np.linspace(0, 2, 9)  # 选取9个数字，从0到2之间
print(h)
print('-----------------------')
h = np.arange(24).reshape(2, 3, 4)  # 将等差数列改变为3维数组
print(h)
print('-----------------------')
h = np.arange(10000)  # 等差数列如果没有第2和第3个参数，则默认步长为1，起点为0的等差数列，如果数组太大，则中间部分省略
print(h)
print('-----------------------')
a = np.array([20, 30, 40, 50])
print(a)
b = np.array(4)
print(b)
c = a - b  # 算术运算是使用元素级别的，创建一个新数组并用结果进行填充
print(c)
d = a ** b
print(d)
print(10 * np.sin(a))
print(a < 35)
print('-----------------------')
a = np.array([[3, 1], [3, 2]])
b = np.array([[2, 0], [3, 4]])
print(a * b)
print('-------')
print(a.dot(b))
print('-------')
print(np.dot(a, b))  # 矩阵乘法
a = np.array([3, 2])
b = np.array([4, 1])
print(np.dot(a, b))
a = np.ones((2, 3), dtype=int)
b = np.random.random((2, 3))
